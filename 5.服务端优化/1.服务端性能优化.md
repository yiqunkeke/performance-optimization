### 服务端性能优化
1. 开启gizip进行性能优化
2. ssr

### 为什么能够通过服务端来进行性能优化呢？
* 因为服务端采用的是 nodeJS，与前端采用的是同一种语言，所以我们可以通过服务端来处理一些复杂的运算，从而减少前端的运算成本。
* 换句话就是，将客户端的运算量放到服务端去做。
* vue-ssr 就是做这么一件事情的。


### chrome 的 performance 分析基于vue框架的SPA应用的性能
* 通过分析允限销系统performance 可以看出，有一大段黄色区域都是在进行scripting，即脚本执行。
* 可以看出在真正页面渲染之前，已经在客户端进行了大量的运算，并执行了大量的js脚本，才将页面渲染出来。
* 这就是现代化前端面临的一个问题。


### vue 渲染面临的问题是什么呢？
* 由于html的整个DOM结构都是在vue框架里面写的，所以整个页面要渲染出来的话，实际上是需要依赖vue框架加载的。
* 整个流程变成了： 先去加载 vue.js ---> 加载完之后再去执行 vue.js 的代码 ----> 从而生成 html页面
* 所以实际上，页面是依赖于整个vue核心代码的加载与执行，而不是直出的html
* 这就会有性能问题。

### 以前没有前端框架时
* 用jsp/php在服务端进行数据的填充
* 发送给客户端就是已经填充好数据的html

* 由于这种方式不是很好进行前端代码的管理，所以上面的方式已经被淘汰。

### 使用 jQuery异步加载数据

### 使用 React 和 Vue 前端框架
* 框架是有代价的：需要等框架的核心代码**异步加载并且执行完**之后，**才能把页面渲染出来**
* 这是导致页面的**首屏渲染性能非常差**。
* 这就是前端发展之下的弊端。

* 优点： 开发体验、开发效率、组件库等非常好、好维护
* 缺点：性能较不使用框架时，有所下降，尤其是首屏渲染问题。

### 机器语言 vs 汇编语言
* 机器语言效率高，但是不友好
* 汇编语言友好，但是效率肯定不及机器语言
* 但是我们不可能回去写机器语言
* 所以，我们也不可能回到不使用前端框架的时候，使用php/jsp时代

### 怎么在 vue 这个层面对性能进行提升 
多层次的优化方案

* 构建层模板编译
    * vue 2.0 中，构建时已经被拆成了2个包：vue / runtime
    * 在 webpack 进行构建的时候，统一将工程所有与template相关的模板语法，直接编译成vue对应的runtime中可以执行的代码
    * 这样在浏览器端，就无需再做模板编译的过程，模板编译的过程放在构建层去做。

* 数据无关情况下，使用 prerender的方式
    * 可以直接在构建的时候，将vue直接render掉，生成对应的html
    * 这样的话，用户可以直接访问这个直出的html
    * 这样在浏览器端完全不用执行vue相关代码，vue相关代码都在构建层执行掉了。

* 服务端渲染
    * 需要从服务端获取相关数据
    * 由于服务端是nodeJs，所以服务端可以执行vue相关的构建、渲染方面的逻辑。
    * 所以服务端可以直接返回客户端一个在服务端就已经渲染好的直出的 html
    * 当然这个直出的html返回给客户端后，客户端还需要将它与vue框架进行混入，因为它的数据还是要通过浏览器端进行管理。









